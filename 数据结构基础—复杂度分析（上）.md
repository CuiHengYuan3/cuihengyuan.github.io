##                               数据结构基础—复杂度分析（上）

  数据结构与算法的目的就是为了让程序运行得更“快”更“小”，就是说执行效率，那么怎么来衡量一个程序的执行效率呢？这就需要贯彻整个数据结构的重要基础，时间，空间复杂度分析。这是是整个算法学习的精髓.

#### 为什么不利用计算机来检测算法的执行时间和空间来评估呢？

  这种评定效率的方法是没有问题的，我们把它称作**事后统计法**

但是这种方法有很大的**局限性**

1. 测试结果非常依赖测试环境

   这可以很好理解，不同的计算机硬件配置不同，是否CPU完全被调用等等环境因素会很大的影响测试结果

2. 测试结果受数据规模的影响很大

   比如排序算法，如果数组本身就是有序的和无序的相比来说执行时间就会很少。还有很多的程序如果数据特殊就会对测试结果影响特别大

那就需要一种不依赖测试环境和数据规模的复杂度分析方法，我们称它为**大O表示法**

### 大O表示法

执行效率，可以表达为程序执行的时间。

看看下面这个方法(java语言描述)

```java
public int calculate(int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum = sum + i;
    }
    return sum;
}
```

很简单的逻辑，这里就不多说了，我们来看看程序的代码各行到底执行了多少次，第二行执行了1次，第2，3行执行了n次，最后一行执行了1次。所以总共执行了2n+2遍。这里的每一行代码都执行的相识的操作，就是读取数据，计算数据，写入数据三步，虽然每行代码的CPU执行时间可能不一样，但是粗略估计，就假设是一样的。假设每一行代码的执行时间是base_time,那么总的时间就是T(n)=base_time*(2n+2)

可以看出，**程序执行的总时间T(n)与每行代码执行的次数之和成正比关系**

总结起来就是大O表示公式

**T(n)=O( f(n) )**

T(n) 表示代码执行的时间；n 表示数据的规模，f(n)表示代码各行执行的次数之和，这个O可以理解为一个正比系数，因为**程序执行的总时间T(n)与每行代码执行的次数之和成正比关系**

所以我们的例子中就是T(n) = O(2n+2)

**这就是大O复杂度表示法**

有一个很重要的需要注意的点：大 O 时间复杂度表示实际上并不具体是代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度，简称为**时间复杂度**

用大O表示法分析时间复杂度有一几个方法：

1.只需要管循环次数最多的那一段代码

前面说了，复杂度表示随着数据规模增大的程序执行时间变化趋势，所以小数量级的阶我们就把它忽略掉。因为随着数据规模的增大，最高阶数量级对程序的执行时间的影响远远大于小数量级规模。所以之前的那个例子就为O（2n）

2.总复杂度等于量级最大的那段代码的复杂度

这与第一条是差不多的

再来一个例子，这个是上一个例子的改版(还是java语言描述)

```java
public int calculate(int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum = sum + i;
    }
    for (int i = 0; i <1000 ; i++) {
        sum = sum + i;
    }
    for (int i = 0; i <n ; i++) {
        for (int j = 0; j <n ; j++) {
            sum = sum + i;
        }
    }
    return sum;
}
```

这个逻辑也太简单不说了，第一个循环执行了n次，第二个执行了1000次，第三个执行了n的平方次。那么就是O(1000+n+n²)，那么依照这条规则，简化为O(n²)

3.嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

直接看例子

```java
public int calculate(int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum = sum + calculate2(i);
    }
    return sum;
}

public int calculate2(int n) {
    int sum1 = 0;
    for (int i = 0; i < n; i++) {
        sum1 = sum1 + i;
    }
    return sum1;
}
```

第一端的复杂度为O（n）,但是每一次里面又是一个循环，又是一个O（n）,所以复杂度为O（n*n）=O(n²)



这些不用刻意去记规则，只要熟练，多看多分析就可以“凭感觉”得出正确答案，真正的高手都是“凭感觉”的。

### 几种常用的复杂度



| 名称      | 常数阶 | 对数阶     | 线性阶 | 线性对数阶   | 平方阶  | 立方阶  | 指数阶   | 阶乘阶  |
| --------- | ------ | ---------- | ------ | ------------ | ------- | ------- | -------- | ------- |
| 大O表达式 | O（1） | O（log n） | O（n） | O（n log n） | O（n²） | O（n³） | O（2^n） | O（n!） |

以上几种复杂度基本上涵盖了绝大部分我们会遇到的复杂度

下面来一一分析一下

### O（1）

首先我问一个问题，O（1）是指代码只执行一行，一次吗？

当然不是，O（1）只是常量阶的表示方法，并不代表指执行一次

**而且就算是执行了100，1000，10000次，只要是常量，那么复杂度都是O（1），可以总结为，只要一段代码执行次数不随数据规模n的变化而变化，更具体的说就是代码中没有循环，递归等，那么复杂度都是O(1)**

### O(log n), O(n log n)

直接看一个例子

```java
public int calculate(int n) {
    int sum = 1;
    for (; sum<n; ) {
        sum = sum*2;
    }
    return sum;
}
```

逻辑一样很简单，再无限循环中每一次sum都乘以2，直到大于n为止

我们设执行次数为x , 那么2^x=n, 运用对数知识，那么x就为log2 n。

那如果我把每次乘以3而不是2呢，那么就是log3 n.

那为什么都可以统一为log n 呢？因为对数是可以转换的，log3n 就等于 log3 2 * log2 n，因为log3 2是一个常数，根据前面说的,这个可以常数忽略掉，就为log2 n.

那么我们忽略对数的底，统一表示为O(log n )

O(n log n)根据前面所说的就是把O(log n)的代码段执行n次，嵌套在O（n）的代码段里面就得到了 O(n log n)。

### O（m+n）,O(m*n)

这个很好理解，有两个未知数，相当于有两个规模，直接看例子

```java
//O（m+n）
public int calculate(int n, int m) {
    int sum = 1;
    for (int i = 0; i < n; i++) {
        sum = sum + i;
    }
    for (int i = 0; i < m; i++) {
        sum = sum + i;
    }
    return sum;
}
```

一看就看懂了，就是这么个意思

```java
//O（m*n）
public int calculate(int n, int m) {
    int sum = 1;
    for (int i = 0; i < n; i++) {
        sum = sum + i;
        for (int j = 0; j < m; j++) {
            sum = sum + i;
        }
    }

    return sum;
}
```

## 空间复杂度分析

空间复杂度分析比时间复杂度简单多了，就是程序申请变量所占的空间

我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，分别对应普通基本数据类型，长度为n的线性表，长度为n的二阶线性表。不会遇到很复杂的时间复杂度

所以，对于空间复杂度，掌握这些内容已经足够了。



