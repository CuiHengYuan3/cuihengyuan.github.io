##                                数据结构基础——链表

#### 零散的内存

如果要申请数组的话，如果没有连续的足够的内存空间，那么就无法申请成功。

链表不需要一块连续的内存空间，**它通过指针把零散的内存空间串联起来。**

链表本身没有大小的限制，天然地支持动态扩容，这是它与数组最大的区别

#### 实现

看看链表的实现（java语言描述）

```java
class ListNode {  
int val; 
ListNode next;   
ListNode(int x){ 
    val = x; 
  }
}
```

ListNode（节点）类包含了一个值和下一个结点的引用（就是相当于C++中的地址指针）

链表的第一个节点叫做**头节点**，最后一个节点叫做**尾节点**，头节点记录的链表的基地址，有了基地址就可以遍历整条链表，**尾节点指向null**,表示整个链表的结束

![1569635157891](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1569635157891.png)



这里有一个地方需要注意：很容易出错

当插入一个节点的时候，很容易这样写

```java
ListNode c=new ListNode(2);
ListNode a=new ListNode(2);
ListNode b=new ListNode(2);
a.next=b;
a.next=c;
c.next=a.next;
```

但是这样是错的，这样会发生指针丢失和内存泄漏，因为当a指向c后，原本的b就没有被指向了，然后c又指向a所指向的，但这个时候a指向的就是c自己，**c自己指向自己**.

**这个一定要先把c指向b，再把a指向c .   如果反着来的话就会c自己指向自己了**

否则就会发生指针丢失和内存泄露。

因为b以及以后的都无法访问了



#### 与数组相比的利和弊

**利：**数组的增加和删除数据会把很多数据移位，但是链表只需要改变左右两个节点的指针就可以了，其他不许要变，所以链表增加和删除数据的复杂度为O(1),数组的增加和删除数据的复杂度O（n），所以链表的增删比数组的性能好很多。

**弊：**链表要访问某个地址的元素只能从头节点开始遍历，直到找到为止，复杂度为O（n）,但是  数组由于其连续的内存空间，所以可以通过寻址公式随机访问元素，复杂度为O（1），所以链表的访问元素比数组的性能差。



#### 常用的链表：循环链表和双向链表

![1569636985437](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1569636985437.png)



**循环链表就是尾节点指向头节点**

双向链表就是一个几点不仅有下一个节点的地址，还有上一个节点的地址

```java
class ListNode {   
int val;   
ListNode next;
ListNode prv; 
ListNode(int x) {  
    val = x;  
}
}
```

很明显，双向链表占用更多的空间，但是更加灵活

比如可以在复杂度为O（1）的条件下找到前驱节点，而普通链表只能从头遍历，只到一个节点的后驱为指定的那个节点，才算找到这个节点的前驱

而且在某些情况下，双向链表的插入和删除比普通链表还要简单（明明普通链表的插入和删除已经很简单了）。

**我们来分析一下删除操作**

删除无非是两种情况

1.删除指定的值的节点。

2.删除指定指针指向的节点

对于第一种情况，无论是普通链表还双向链表都需要从头遍历。

对于第二种情况，如果要删除指定的节点，那么就要找到它的前驱节点，上面分析了，如果普通链表只能从头遍历，只到一个节点的后驱为指定的那个节点，才算找到这个节点的前驱。而双向链表直接就可以找到，因为本身就有前驱节点的指针。

这就是**空间换时间的思想**，如果内存很紧张，那么就不要用双向表，如果内存空余很多，追求性能快，那么就用双向表



#### 在计算机底层设计中的应用-用链表实现LRU缓存

基本的思路是

1.维护一个链表，越早被访问过的对象越在链表的后面，越新被访问过的对象越靠近链表的头部

2.当一个对象被访问的时候，遍历这个链表，如果在链表中找到了这个对象，那么就把它重新放到链表头部，如果没有找到，就把这个对象包装为一个新的节点放到链表头部。

3.插入的时候如果链表满了，就删除一部分靠近链表尾部的对象(差不多是这个思路，具体实现看情况)

4.如果内存紧张了同上。



**小结一下**：数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

这里插入一个知识：

  CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。

对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。  



#### 关于链表的技巧

利用哨兵简化实现难度

如果是普通的插入

```c
new_node->next = p->next;
p->next = new_node;

```

但是如果是在一个空链表上插入第一个节点

就要这样的逻辑

```c++
if (head == null) {
  head = new_node;
}
```

然后是删除一个节点的后一个节点

```c++
p->next = p->next->next;
```

但是如果是删除最后一个节点呢，上面的就不管用了，需要这样写

```c++
if (head->next == null) {
   head = null;
}
```

那么有没有什么可以使头节点和尾节点的删除和添加和其他节点一样呢？这样可以增加容错率，代码可读性

**利用哨兵节点**，哨兵顾名思义就是解决边界的问题。

我们用head==null表示空链表，head表示指向头节点的指针。

我们新增一个哨兵节点，哨兵节点不储存数据，无论链表是否为空，head指针都指向哨兵节点。

![1569641552168](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1569641552168.png)



 

```
          ListNode head=new  ListNode(-1);//创建哨兵，head就是哨兵的引用，也就是指向哨兵的指针             ListNode first=new ListNode(2);
          first.next=head.next;
          head.next=first;
```





#### 重点留意边界条件处理

经常用来检查链表是否正确的边界4个边界条件：
1.如果链表为空时，代码是否能正常工作？
2.如果链表只包含一个节点时，代码是否能正常工作？
3.如果链表只包含两个节点时，代码是否能正常工作？
4.代码逻辑在处理头尾节点时是否能正常工作？



没有实战是不行的

下一篇我会做leetcode上面一下关于链表的题目来讲解一下。



