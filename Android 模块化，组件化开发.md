#               Android 模块化，组件化开发（未完）



### 引言：

  随着业务逻辑的越来越复杂，功能越来越丰富，工程代码不停添加如果没有一个好的架构所有代码将会强耦合在一起，功能直接也会有很多依赖，那么就会出现很多问题。**解耦，是大型工程项目所必须的，**也是开发中程序编写者所必须掌握的“技能”，打了一个引号是因为解耦手段方法繁多，各种开发中有不同的方式。那么在安卓中有一个强大的解耦方案就是组件化（模块化）开发。

**模块化开发**：将一个程序按照其功能做拆分，分成相互独立的模块，以便于每个模块只包含与其功能相关的内容。模块我们相对熟悉,比如登录功能可以是一个模块,搜索功能可以是一个模块

  以往，没有了解模块化的时候，我们其实也是采用的相似的思想 或者说已经不知不觉中用了模块化 ，比如把网络通信相关类放入一个专门的包中，把一些常用工具类放入另一个包中，把json对应的实体类单独放入一个包中，把UI类单独放入一个包中，等等。采用的思想都是把各个功能的模块分开（以包的形式），**模块化思想也是一样的，只不过各个模块更加独立，独立到每一个模块都可以形成一个单独的APK**！！！！！

**组件式开发**：

基于可重用的目的，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件，已较少耦合。

将一个app分成多个模块，每个模块都是一个组件（Module），开发的过程中我们可以让这些组件相互依赖或者单独调试部分组件等，但是最终发布的时候是将这些组件合并统一成一个apk，这就是组件化开发。

Module的模式分两种， application和library。 library就是引用库，如你抽取的common。 application就是一个apk， 是一个完整的项目。

正常一个App中可以有多个module，但是一般只会有一个module是设置为application的，其他均设置为library，组件化开发就是要每个module都可以运行起来，因此在开发期间(Debug版本)每个module均设置为application，发布时(Release版本)设置为libs再进行合并。

**模块化粒度更小,更侧重于重用,而组件化粒度稍大于模块,更侧重于业务解耦。**



![æ³ä¸å°å§](http://ww3.sinaimg.cn/large/9150e4e5gy1g739y7tw6fj206a060aa0.jpg)

没有模块化前：![1568817004586](https://s2.ax1x.com/2019/09/20/nvDJQP.png)





### 如何创建一个新的模块：

![1568990681643](https://s2.ax1x.com/2019/09/20/nvD5WR.png)



![1568990703037](https://s2.ax1x.com/2019/09/20/nvDTQx.md.png)



![1568990733237](https://s2.ax1x.com/2019/09/20/nvDoS1.png)



这样就创建好了一个新的模块（此处是Library）



接下来就来简单的看一下，这是组件化开发的图

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20180108100708094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWhoeW91Y29t/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

如图所示，一个App有四个组件，组件之间

1、主工程（壳工程mudele）：主要负责事情不塞入任何具体业务逻辑，**主要用于使用组合业务组件、初始化配置和发布应用配置等操作**。

2、组件（module/library）：主要实现具体业务逻辑，尽可能保证业务独立性，**每个bu功能块都能够拿出来作为一个独立业务app。**

3、公共库（library）：公共使用的工具类、sdk等库，例如eventbus、xutils、rxandroid、自定义工具类等等，这些库可以做成一个公共common sdk、也可以实现抽离很细按照需求依赖使用。
他们之间的关系则是 **主工程依赖组件、组件依赖公共库**。



组件开发中分为两种模式一种开发测试模式、一种是发布模式：
1、开发测试模式：这种模式下面组件应该是独立module模式，module是可以独立运行的，只要保证他对其他业务没有依赖就可以独立开发测试。
2、发布模式：这时候组件应该library模式被主工程依赖组合，发布运行，所有业务将组合成完整app发布运行。

   这些业务组件在集成模式下是一个个library，被app壳工程所依赖，组成一个具有完整业务功能的APP应用，但是在组件开发模式下，业务组件又变成了一个个application，它们可以独立开发和调试，由于在组件开发模式下，业务组件们的代码量相比于完整的项目差了很远，因此在运行时可以显著减少编译时间。

这张专业术语表可以让你更清晰从认识组件化：

| 集成模式   | 所有的业务组件被“app壳工程”依赖，组成一个完整的APP；         |
| ---------- | ------------------------------------------------------------ |
| 组件模式   | 可以独立开发业务组件，每一个业务组件就是一个APP；            |
| app壳工程  | 负责管理各个业务组件，和打包apk，**没有具体的业务功能；**    |
| 业务组件   | 根据公司具体业务而独立形成一个的工程；                       |
| 功能组件   | 提供开发APP的某些基础功能，例如打印日志、树状图等            |
| Main组件   | 属于业务组件，指定APP启动页面、主界面；                      |
| Common组件 | 属于功能组件，支撑业务组件的基础，提供多数业务组件需要的功能，例如提供网络请求功能； |



### 实施流程





Android Studio中的Module主要有两种属性，分别为：

1、application属性，可以独立运行的Android程序，也就是我们的APP；

​       apply plugin: ‘com.android.application’

2、library属性，不可以独立运行，一般是Android程序依赖的库文件；

​      apply plugin: ‘com.android.library’

![1568865972301](https://s2.ax1x.com/2019/09/20/nvDtL8.md.png)

Module的属性是在每个组件的 build.gradle 文件中配置的，当我们在组件模式开发时，业务组件应处于application属性，这时的业务组件就是一个 Android App，可以独立开发和调试；而当我们转换到集成模式开发时，业务组件应该处于 library 属性，这样才能被我们的“app壳工程”所**依赖**，组成一个具有完整功能的APP；

  当然可以手动改，但是如果模块多了咋办？还要一个个手改吗？

![img](https://img.doutula.com/production/uploads/image/2018/05/31/20180531698460_qfCMJY.gif)

当然不是，这种依赖于一个布尔量的改变而改变的情况肯定是先定义一个全局静态变量，然后每个模块依据这个变量来改变Module的属性啊。只不过我们把这个变量定义在Gradle中（Gradle来构建一个android项目）

  每当我们用AndroidStudio创建一个Android项目后，就会在项目的根目录中生成一个文件 gradle.properties，我们将使用这个文件的一个重要属性：**在Android项目中的任何一个build.gradle文件中都可以把gradle.properties中的常量读取出来**。（这不就是类似于全局静态变量吗？）这正是我们想要的。

![1568866525561](https://s2.ax1x.com/2019/09/20/nvD8zt.png)



![1568866710813](https://s2.ax1x.com/2019/09/20/nvDYsf.md.png)

再点击右上角的sync Now同步

然后在每个模块的build.gradle中加入判断

**gradle.properties 中的数据类型都是String类型，使用其他数据类型需要自行转换；**也就是说我们读到 isModule 是个String类型的值，而我们需要的是Boolean值，所以要toBoolean().

![1568866947245](https://s2.ax1x.com/2019/09/20/nvDUeS.png)

​                     **别忘了同步**





## 组件之间AndroidManifest合并

由于每一个组件都可以是一个单独的APK,那么相应的每一个组件都有一个自己的AndroidManifest，里面配置自己的限权，launch Acitvity等，但是在集成模式的时候就会发生冲突，因为一个App不会有多个launch Activity和多个注册文件

..............未完待续





